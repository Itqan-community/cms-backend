{% extends "admin/base_site.html" %}
{% load static %}

{% block content %}
  {{ surah_map_en|json_script:"surah-map-en" }}
  {{ surah_map_ar|json_script:"surah-map-ar" }}
  <form id="bulkUploadForm" method="post" enctype="multipart/form-data" action="" style="max-width:900px;">
      {% csrf_token %}
      <table style="margin-bottom:12px;">
          {{ form.as_table }}
      </table>
      <div id="filePreview" style="display:none; margin:12px 0; padding:10px; border:1px solid #444; border-radius:6px;">
        <div style="margin-bottom:8px; font-weight:600;">Selected files</div>
        <ul id="filePreviewList" style="list-style: none; padding-left: 0; margin:0;"></ul>
        <div id="filePreviewSummary" style="margin-top:8px; font-size:12px; color:#aaa;"></div>
      </div>
      <div id="progressWrap" style="margin-top:12px; display:none;">
        <progress id="uploadProgress" max="100" value="0" style="width:100%;"></progress>
        <div id="progressText" style="margin-top:6px; font-size:12px;">Preparing upload…</div>
        <div id="uploadStatus" style="margin-top:6px; font-size:12px; color:#555;">
          Please do not close or navigate away from this page until the upload is fully finished.
        </div>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px;">
        <input type="submit" value="Upload" class="default" id="submitBtn">
      </div>
  </form>
  <script>
    (function() {
      // Surah name maps injected by server (safe via json_script)
      const SURAH_MAP_EN = JSON.parse(document.getElementById('surah-map-en').textContent);
      const SURAH_MAP_AR = JSON.parse(document.getElementById('surah-map-ar').textContent);
      const assetId = window.location.pathname.match(/\/(\d+)\//)?.[1];
      const form = document.getElementById('bulkUploadForm');
      if (!form) return;
      const fileInput = form.querySelector('input[name="audio_files"]');
      const filePreview = document.getElementById('filePreview');
      const filePreviewList = document.getElementById('filePreviewList');
      const filePreviewSummary = document.getElementById('filePreviewSummary');
      let currentXhr = null;

      function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
      }

      function bytesToReadable(bytes) {
        if (!bytes || isNaN(bytes)) return '0 B';
        const units = ['B','KB','MB','GB','TB'];
        let i = 0;
        let num = bytes;
        while (num >= 1024 && i < units.length - 1) {
          num = num / 1024;
          i++;
        }
        return `${num.toFixed(1)} ${units[i]}`;
      }

      // Helper function to extract duration from audio file
      async function extractAudioDuration(file) {
        return new Promise((resolve) => {
          try {
            const audio = document.createElement('audio');
            audio.preload = 'metadata';

            audio.onloadedmetadata = function() {
              window.URL.revokeObjectURL(audio.src);
              const durationSeconds = audio.duration;
              if (durationSeconds && isFinite(durationSeconds)) {
                const durationMs = Math.round(durationSeconds * 1000);
                resolve(durationMs);
              } else {
                resolve(null);
              }
            };

            audio.onerror = function() {
              window.URL.revokeObjectURL(audio.src);
              resolve(null);
            };

            audio.src = window.URL.createObjectURL(file);
          } catch (error) {
            console.warn('Failed to extract audio duration:', error);
            resolve(null);
          }
        });
      }

      // Store durations extracted during preview
      let fileDurations = {};

      async function refreshPreview() {
        if (!fileInput) return;
        const files = Array.from(fileInput.files || []);
        if (!files.length) {
          filePreview.style.display = 'none';
          fileDurations = {};
          return;
        }

        // Clear previous durations
        fileDurations = {};

        // Extract durations from all files in parallel
        const durationPromises = files.map(async (file) => {
          const duration = await extractAudioDuration(file);
          if (duration !== null) {
            fileDurations[file.name] = duration;
          }
        });

        // Wait for all duration extractions (non-blocking for validation)
        Promise.all(durationPromises).catch(err => {
          console.warn('Some durations failed to extract:', err);
        });

        // Call backend validation endpoint
        const validateUrl = "{% url 'admin:asset_validate_recitation_filenames' %}";
        try {
          const response = await fetch(validateUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken') || ''
            },
            credentials: 'same-origin',
            body: JSON.stringify({
              filenames: files.map(f => f.name),
              asset_id: assetId
            }),
          });

          if (!response.ok) {
            throw new Error('Validation request failed');
          }

          const { results } = await response.json();

          // Render validation results
          filePreview.style.display = 'block';
          filePreviewList.innerHTML = '';

          let invalid = 0;
          let dupInSelection = 0;
          let dupInDb = 0;
          let totalBytes = 0;
          const seenSurahs = new Set();

          results.forEach((result, idx) => {
            const file = files[idx];
            totalBytes += file?.size || 0;

            const li = document.createElement('li');
            li.style.margin = '4px 0';

            if (!result.valid) {
              li.style.color = '#ff6b6b';
              li.textContent = `${result.filename} —  invalid filename, can't extract surah number`;
              invalid++;
            } else {
              const sn = result.surah_number;

              // Check for duplicates within selection
              if (seenSurahs.has(sn)) {
                li.style.color = '#f0ad4e';
                li.textContent = `${result.filename} — duplicate in selection (surah ${sn})`;
                dupInSelection++;
              } else {
                seenSurahs.add(sn);

                // Check if exists in database
                if (result.exists) {
                  li.style.color = '#f0ad4e';
                  li.textContent = `${result.filename} — already exists in database (surah ${sn})`;
                  dupInDb++;
                } else {
                  // Valid file
                  const en = result.surah_name_en || '';
                  const ar = result.surah_name_ar || '';
                  li.textContent = `${result.filename} — surah ${sn} ${en ? `(${en})` : ''} ${ar ? `- ${ar}` : ''}`;
                }
              }
            }

            filePreviewList.appendChild(li);
          });

          // Build summary message
          const warnings = [];
          if (invalid) warnings.push(`${invalid} invalid filename(s)`);
          if (dupInSelection) warnings.push(`${dupInSelection} duplicate(s) in selection`);

          filePreviewSummary.textContent = warnings.length
            ? `Warnings: ${warnings.join(', ')}. Existing tracks in the database will be skipped automatically. Total size: ${bytesToReadable(totalBytes)}.`
            : `Looks good. Existing tracks in the database will be skipped automatically. Total size: ${bytesToReadable(totalBytes)}.`;

          // Disable submit if invalid files
          document.getElementById('submitBtn').disabled = invalid > 0;

        } catch (error) {
          console.error('Validation error:', error);
          filePreview.style.display = 'block';
          filePreviewList.innerHTML = '<li style="color:#ff6b6b;">Failed to validate filenames. Please try again.</li>';
          document.getElementById('submitBtn').disabled = true;
        }
      }

      if (fileInput) {
        fileInput.addEventListener('change', refreshPreview);
        // Initialize on load if files are kept by browser
        if (fileInput.files && fileInput.files.length) {
          refreshPreview();
        }
      }

      form.addEventListener('submit', function(e) {
        // Use XHR to get upload progress while preserving server-side messages
        e.preventDefault();

        const progressWrap = document.getElementById('progressWrap');
        const progressBar = document.getElementById('uploadProgress');
        const progressText = document.getElementById('progressText');
        const statusText = document.getElementById('uploadStatus');
        const submitBtn = document.getElementById('submitBtn');

        progressWrap.style.display = 'block';
        progressBar.value = 0;
        progressText.textContent = '0%';
        statusText.textContent = 'Uploading files… Please do not close this page.';
        submitBtn.disabled = true;

        const xhr = new XMLHttpRequest();
        currentXhr = xhr;
        xhr.open('POST', form.getAttribute('action') || window.location.href, true);
        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        const csrftoken = getCookie('csrftoken');
        if (csrftoken) {
          xhr.setRequestHeader('X-CSRFToken', csrftoken);
        }

        xhr.upload.onprogress = function(event) {
          if (event.lengthComputable) {
            const percent = Math.round((event.loaded / event.total) * 100);
            progressBar.value = percent;
            progressText.textContent = percent + '% (' + bytesToReadable(event.loaded) + ' / ' + bytesToReadable(event.total) + ')';
            if (percent >= 100) {
              // Phase 2: client finished sending; server is finalizing (writing chunks, creating DB rows, etc.)
              // Switch to indeterminate progress to reflect server-side processing time.
              progressBar.removeAttribute('value');
              progressText.textContent = 'Upload sent. Finalizing on server…';
              statusText.textContent = 'Please do not close this page until the upload is fully finished.';
            }
          } else {
            // Unknown length -> indeterminate
            progressBar.removeAttribute('value');
            progressText.textContent = 'Uploading…';
            statusText.textContent = 'Please do not close this page until the upload is fully finished.';
          }
        };

        xhr.onload = function() {
          // After server sets messages and redirects, navigate to final URL to show messages
          try {
            // Restore to complete state just before redirect for a better UX
            progressBar.setAttribute('value', '100');
            progressText.textContent = 'Completed. Redirecting…';
            statusText.textContent = 'Upload finished.';
          } catch (e) {}
          const target = xhr.responseURL || "{{ redirect_url|default:'' }}";
          window.location.href = target || window.location.href;
        };

        xhr.onerror = function() {
          // As a fallback, submit the form normally
          statusText.textContent = 'Network error encountered. Retrying with standard submission…';
          form.submit();
        };

        const formData = new FormData(form);

        // Add durations as JSON string if we have any
        if (Object.keys(fileDurations).length > 0) {
          formData.append('durations_json', JSON.stringify(fileDurations));
        }

        xhr.send(formData);
      });
    })();
  </script>
{% endblock %}
