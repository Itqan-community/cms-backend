name: CI/CD Pipeline

on:
  # Auto-deploy on direct pushes to develop branch (development workflow)
  push:
    branches: [develop]

  # Deployment triggered by pull request merges to enforce branch flow
  pull_request:
    types: [closed]
    branches: [staging, main]  # Only staging and main require PRs

  # Allow manual deployment trigger for develop branch only (for hotfixes)
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy (develop only)'
        required: true
        default: 'develop'
        type: choice
        options:
          - develop

jobs:
  # Deployment Job with Container Cleanup
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    # Run on: direct push to develop, merged PRs to staging/main, or manual dispatch
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/develop') ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_dispatch')

    steps:
      - name: Validate branch flow rules
        run: |
          echo "ğŸ” Validating deployment rules..."

          if [[ "${{ github.event_name }}" == "push" ]]; then
            PUSH_BRANCH="${{ github.ref_name }}"
            echo "   Direct Push to: $PUSH_BRANCH"

            # Only develop branch allows direct pushes for auto-deployment
            if [[ "$PUSH_BRANCH" == "develop" ]]; then
              echo "âœ… Direct push to develop branch - auto-deployment authorized"
            else
              echo "âŒ ERROR: Direct pushes only allowed to develop branch"
              echo "   Use Pull Requests for staging and main branches"
              exit 1
            fi

          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"

            echo "   Pull Request: $HEAD_BRANCH â†’ $BASE_BRANCH"

            # Rule 1: Main can only receive merges from staging
            if [[ "$BASE_BRANCH" == "main" && "$HEAD_BRANCH" != "staging" ]]; then
              echo "âŒ ERROR: Production (main) can only be updated from staging branch"
              echo "   Attempted: $HEAD_BRANCH â†’ main"
              echo "   Required: staging â†’ main"
              exit 1
            fi

            # Rule 2: Staging can only receive merges from develop
            if [[ "$BASE_BRANCH" == "staging" && "$HEAD_BRANCH" != "develop" ]]; then
              echo "âŒ ERROR: Staging can only be updated from develop branch"
              echo "   Attempted: $HEAD_BRANCH â†’ staging"
              echo "   Required: develop â†’ staging"
              exit 1
            fi

            echo "âœ… Branch flow rules validated successfully"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            DISPATCH_BRANCH="${{ github.event.inputs.branch }}"
            if [[ "$DISPATCH_BRANCH" != "develop" ]]; then
              echo "âŒ ERROR: Manual deployment only allowed for develop branch"
              exit 1
            fi
            echo "âœ… Manual deployment authorized for develop branch"
          fi

      - name: Set deployment variables
        id: vars
        run: |
          # Robust lowercase owner for GHCR (some shells reject ${var,,})
          OWNER_LC=$(echo "$GITHUB_REPOSITORY_OWNER" | tr '[:upper:]' '[:lower:]')
          # Determine target branch
          if [[ "${{ github.event_name }}" == "push" ]]; then
            TARGET_BRANCH="${{ github.ref_name }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            TARGET_BRANCH="${{ github.event.pull_request.base.ref }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TARGET_BRANCH="${{ github.ref_name }}"
          fi

          if [[ "$TARGET_BRANCH" == "develop" ]]; then
            echo "HOST=${{ secrets.DEVELOP_HOST }}" >> $GITHUB_ENV
            echo "ENV_NAME=development" >> $GITHUB_ENV
            echo "ENV_URL=https://develop.api.cms.itqan.dev" >> $GITHUB_ENV
            echo "COMPOSE_FILE=deployment/docker/docker-compose.develop.yml" >> $GITHUB_ENV
            echo "BRANCH=develop" >> $GITHUB_ENV
            echo "IMAGE_REPO=ghcr.io/${OWNER_LC}/cms-backend" >> $GITHUB_ENV
            echo "IMAGE_TAG=develop-${GITHUB_SHA::7}" >> $GITHUB_ENV
          elif [[ "$TARGET_BRANCH" == "staging" ]]; then
            echo "HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
            echo "ENV_NAME=staging" >> $GITHUB_ENV
            echo "ENV_URL=https://staging.api.cms.itqan.dev" >> $GITHUB_ENV
            echo "COMPOSE_FILE=deployment/docker/docker-compose.staging.yml" >> $GITHUB_ENV
            echo "BRANCH=staging" >> $GITHUB_ENV
            echo "IMAGE_REPO=ghcr.io/${OWNER_LC}/cms-backend" >> $GITHUB_ENV
            echo "IMAGE_TAG=staging-${GITHUB_SHA::7}" >> $GITHUB_ENV
          elif [[ "$TARGET_BRANCH" == "main" ]]; then
            echo "HOST=${{ secrets.PROD_HOST }}" >> $GITHUB_ENV
            echo "ENV_NAME=production" >> $GITHUB_ENV
            echo "ENV_URL=https://api.cms.itqan.dev" >> $GITHUB_ENV
            echo "COMPOSE_FILE=deployment/docker/docker-compose.production.yml" >> $GITHUB_ENV
            echo "BRANCH=main" >> $GITHUB_ENV
            echo "IMAGE_REPO=ghcr.io/${OWNER_LC}/cms-backend" >> $GITHUB_ENV
            echo "IMAGE_TAG=prod-${GITHUB_SHA::7}" >> $GITHUB_ENV
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image to GHCR
        run: |
          echo "ğŸ› ï¸ Building image $IMAGE_REPO:$IMAGE_TAG for ${{ env.ENV_NAME }} environment"
          docker build -f deployment/docker/Dockerfile.backend -t $IMAGE_REPO:$IMAGE_TAG .

          echo "ğŸ“¤ Pushing image to GHCR..."
          echo "ğŸ” Repository: $IMAGE_REPO"
          echo "ğŸ·ï¸ Tag: $IMAGE_TAG"

          # Make the repository public on first push (GHCR requirement)
          echo "ğŸ“¦ Creating/updating GHCR repository..."

          # Retry push up to 3 times with exponential backoff
          for attempt in 1 2 3; do
            echo "ğŸ”„ Push attempt $attempt/3..."
            if docker push $IMAGE_REPO:$IMAGE_TAG; then
              echo "âœ… Image pushed successfully to GHCR on attempt $attempt"
              break
            else
              if [ $attempt -eq 3 ]; then
                echo "âŒ All push attempts failed"
                exit 1
              fi
              wait_time=$((attempt * 10))
              echo "â³ Waiting ${wait_time}s before retry..."
              sleep $wait_time
            fi
          done

      - name: Deploy to ${{ env.ENV_NAME }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            echo "ğŸš€ Starting deployment to ${{ env.ENV_NAME }} environment..."
            echo "ğŸ“‹ Target: ${{ env.ENV_URL }}"
            echo "ğŸŒ¿ Branch: ${{ env.BRANCH }}"

            # Navigate to application directory
            cd /srv/cms-backend

            # Pull latest changes
            echo "ğŸ“¥ Fetching latest code from GitHub..."
            git fetch origin ${{ env.BRANCH }}
            git reset --hard origin/${{ env.BRANCH }}

            # Display current commit
            echo "ğŸ“‹ Current commit: $(git rev-parse --short HEAD) - $(git log -1 --pretty=%B)"

            # Generate environment file from GitHub Secrets (per environment)
            echo "ğŸ§© Generating environment file from secrets..."
            mkdir -p deployment/docker
            if [ "${{ env.ENV_NAME }}" = "development" ]; then
              {
                echo "DJANGO_SETTINGS_MODULE=config.settings.development";
                echo "SECRET_KEY=${{ secrets.DEVELOP_SECRET_KEY }}";
                echo "DEBUG=False";
                echo "SITE_DOMAIN=develop.api.cms.itqan.dev";
                echo "DB_ENGINE=django.db.backends.postgresql";
                echo "DB_NAME=${{ secrets.DEVELOP_DB_NAME }}";
                echo "DB_USER=${{ secrets.DEVELOP_DB_USER }}";
                echo "DB_PASSWORD=${{ secrets.DEVELOP_DB_PASSWORD }}";
                echo "DB_HOST=${{ secrets.DEVELOP_DB_HOST }}";
                echo "DB_PORT=25060";
                echo "PGSSLMODE=require";
                echo "ALLOWED_HOSTS=develop.api.cms.itqan.dev";
                echo "CORS_ALLOWED_ORIGINS=https://dev.cms.itqan.dev,http://localhost:3000";
                echo "CLOUDFLARE_R2_BUCKET=${{ secrets.DEVELOP_CLOUDFLARE_R2_BUCKET }}";
                echo "CLOUDFLARE_R2_ENDPOINT=${{ secrets.CLOUDFLARE_R2_ENDPOINT }}";
                echo "CLOUDFLARE_R2_ACCESS_KEY_ID=${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}";
                echo "CLOUDFLARE_R2_SECRET_ACCESS_KEY=${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}";
                echo "CLOUDFLARE_R2_PUBLIC_BASE_URL=${{ secrets.DEVELOP_CLOUDFLARE_R2_PUBLIC_BASE_URL }}";
                echo "EMAIL_BACKEND=${{ secrets.DEVELOP_EMAIL_BACKEND }}";
              } > deployment/docker/.env
            elif [ "${{ env.ENV_NAME }}" = "staging" ]; then
              {
                echo "DJANGO_SETTINGS_MODULE=config.settings.staging";
                echo "SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}";
                echo "DEBUG=False";
                echo "SITE_DOMAIN=staging.api.cms.itqan.dev";
                echo "DB_ENGINE=django.db.backends.postgresql";
                echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}";
                echo "DB_USER=${{ secrets.STAGING_DB_USER }}";
                echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}";
                echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}";
                echo "DB_PORT=25060";
                echo "PGSSLMODE=require";
                echo "ALLOWED_HOSTS=staging.api.cms.itqan.dev";
                echo "CORS_ALLOWED_ORIGINS=https://staging.cms.itqan.dev,http://localhost:3000";
                echo "CLOUDFLARE_R2_BUCKET=${{ secrets.STAGING_CLOUDFLARE_R2_BUCKET }}";
                echo "CLOUDFLARE_R2_ENDPOINT=${{ secrets.CLOUDFLARE_R2_ENDPOINT }}";
                echo "CLOUDFLARE_R2_ACCESS_KEY_ID=${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}";
                echo "CLOUDFLARE_R2_SECRET_ACCESS_KEY=${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}";
                echo "CLOUDFLARE_R2_PUBLIC_BASE_URL=${{ secrets.STAGING_CLOUDFLARE_R2_PUBLIC_BASE_URL }}";
                echo "EMAIL_BACKEND=${{ secrets.STAGING_EMAIL_BACKEND }}";
              } > deployment/docker/.env
            elif [ "${{ env.ENV_NAME }}" = "production" ]; then
              {
                echo "DJANGO_SETTINGS_MODULE=config.settings.production";
                echo "SECRET_KEY=${{ secrets.PROD_SECRET_KEY }}";
                echo "DEBUG=False";
                echo "SITE_DOMAIN=api.cms.itqan.dev";
                echo "DB_ENGINE=django.db.backends.postgresql";
                echo "DB_NAME=${{ secrets.PROD_DB_NAME }}";
                echo "DB_USER=${{ secrets.PROD_DB_USER }}";
                echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}";
                echo "DB_HOST=${{ secrets.PROD_DB_HOST }}";
                echo "DB_PORT=25060";
                echo "PGSSLMODE=require";
                echo "ALLOWED_HOSTS=api.cms.itqan.dev";
                echo "CORS_ALLOWED_ORIGINS=https://cms.itqan.dev";
                echo "CLOUDFLARE_R2_BUCKET=${{ secrets.PROD_CLOUDFLARE_R2_BUCKET }}";
                echo "CLOUDFLARE_R2_ENDPOINT=${{ secrets.CLOUDFLARE_R2_ENDPOINT }}";
                echo "CLOUDFLARE_R2_ACCESS_KEY_ID=${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}";
                echo "CLOUDFLARE_R2_SECRET_ACCESS_KEY=${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}";
                echo "CLOUDFLARE_R2_PUBLIC_BASE_URL=${{ secrets.PROD_CLOUDFLARE_R2_PUBLIC_BASE_URL }}";
                echo "EMAIL_BACKEND=${{ secrets.PRODUCTION_EMAIL_BACKEND }}";
              } > deployment/docker/.env
            fi
            # Append image coordinates for docker compose variable substitution
            echo "IMAGE_REPO=${{ env.IMAGE_REPO }}" >> deployment/docker/.env
            echo "IMAGE_TAG=${{ env.IMAGE_TAG }}" >> deployment/docker/.env
            echo "âœ… Environment file generated at deployment/docker/.env (with IMAGE_REPO/IMAGE_TAG)"

            # Clean up existing containers and images
            echo "ğŸ§¹ Cleaning up existing containers..."
            docker compose -f ${{ env.COMPOSE_FILE }} down --remove-orphans || true
            docker container prune -f || true
            docker system prune -f || true

            # Remove any conflicting containers by name (more comprehensive)
            echo "ğŸ—‘ï¸ Removing any conflicting containers..."
            docker rm -f docker-web-1 docker-caddy-1 web caddy cms-web backend || true
            docker network prune -f || true

            # Authenticate Docker to GHCR for all environments
            if [ -n "${{ secrets.GHCR_DEPLOY_USER }}" ] && [ -n "${{ secrets.GHCR_DEPLOY_TOKEN }}" ]; then
              echo "ğŸ” Logging in to GHCR on remote host for ${{ env.ENV_NAME }} environment..."
              echo "${{ secrets.GHCR_DEPLOY_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_DEPLOY_USER }}" --password-stdin || {
                echo "âŒ GHCR login failed on remote host"; exit 1; }
            else
              echo "âš ï¸ GHCR_DEPLOY_USER/TOKEN not set; using GitHub token for ${{ env.ENV_NAME }} environment"
              echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.repository_owner }}" --password-stdin || {
                echo "âŒ GHCR login failed with GitHub token"; exit 1; }
            fi

            # Deploy with Docker Compose (pull and start)
            echo "ğŸ”§ Pulling and starting services..."
            IMG_REPO='${{ env.IMAGE_REPO }}'
            IMG_TAG='${{ env.IMAGE_TAG }}'
            echo "Using image: ${IMG_REPO}:${IMG_TAG}"

            # Pull fresh image from GHCR for all environments
            echo "ğŸ“¦ Pulling fresh image from GHCR for ${{ env.ENV_NAME }} environment..."
            IMAGE_REPO="${IMG_REPO}" IMAGE_TAG="${IMG_TAG}" docker compose -f ${{ env.COMPOSE_FILE }} pull
            IMAGE_REPO="${IMG_REPO}" IMAGE_TAG="${IMG_TAG}" docker compose -f ${{ env.COMPOSE_FILE }} up -d

            # Wait for services to be ready
            echo "â³ Waiting for services to start..."
            sleep 30

            # Health check
            echo "ğŸ” Performing health check..."
            if curl -f -s ${{ env.ENV_URL }}/health > /dev/null; then
              echo "âœ… Health check passed!"
            else
              echo "âš ï¸ Health check failed, checking container status..."
              docker compose -f ${{ env.COMPOSE_FILE }} ps
              docker compose -f ${{ env.COMPOSE_FILE }} logs web --tail 20
            fi

            # Clean up old Docker images
            echo "ğŸ§¹ Cleaning up old Docker images..."

            # Remove dangling images
            docker image prune -f || true

            # Remove old CMS images, keeping only the 3 most recent for rollback
            echo "ğŸ“¦ CMS images before cleanup: $(docker images 'ghcr.io/*/cms-backend' -q | wc -l)"
            docker images "ghcr.io/*/cms-backend" --format "{{.ID}} {{.CreatedAt}}" | \
              sort -k2,3 -r | tail -n +4 | awk '{print $1}' | \
              xargs -r docker rmi -f 2>/dev/null || true
            echo "ğŸ“¦ CMS images after cleanup: $(docker images 'ghcr.io/*/cms-backend' -q | wc -l)"

            # Remove old caddy images, keeping 2 recent
            docker images "caddy" --format "{{.ID}} {{.CreatedAt}}" | \
              sort -k2,3 -r | tail -n +3 | awk '{print $1}' | \
              xargs -r docker rmi -f 2>/dev/null || true

            # Final cleanup of orphaned layers
            docker system prune -f || true

            echo "ğŸ‰ Deployment to ${{ env.ENV_NAME }} completed successfully!"
            echo "ğŸŒ Application URL: ${{ env.ENV_URL }}"
