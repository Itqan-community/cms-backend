name: CI/CD Pipeline

on:
  # Auto-deploy on direct pushes to develop branch (development workflow)
  push:
    branches: [develop]
  
  # Deployment triggered by pull request merges to enforce branch flow
  pull_request:
    types: [closed]
    branches: [staging, main]  # Only staging and main require PRs
  
  # Allow manual deployment trigger for develop branch only (for hotfixes)
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy (develop only)'
        required: true
        default: 'develop'
        type: choice
        options:
          - develop

jobs:
  # Deployment Job with Container Cleanup
  deploy:
    runs-on: ubuntu-latest
    # Run on: direct push to develop, merged PRs to staging/main, or manual dispatch
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/develop') ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_dispatch')
    
    steps:
      - name: Validate branch flow rules
        run: |
          echo "ğŸ” Validating deployment rules..."
          
          if [[ "${{ github.event_name }}" == "push" ]]; then
            PUSH_BRANCH="${{ github.ref_name }}"
            echo "   Direct Push to: $PUSH_BRANCH"
            
            # Only develop branch allows direct pushes for auto-deployment
            if [[ "$PUSH_BRANCH" == "develop" ]]; then
              echo "âœ… Direct push to develop branch - auto-deployment authorized"
            else
              echo "âŒ ERROR: Direct pushes only allowed to develop branch"
              echo "   Use Pull Requests for staging and main branches"
              exit 1
            fi
            
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
            
            echo "   Pull Request: $HEAD_BRANCH â†’ $BASE_BRANCH"
            
            # Rule 1: Main can only receive merges from staging
            if [[ "$BASE_BRANCH" == "main" && "$HEAD_BRANCH" != "staging" ]]; then
              echo "âŒ ERROR: Production (main) can only be updated from staging branch"
              echo "   Attempted: $HEAD_BRANCH â†’ main"
              echo "   Required: staging â†’ main"
              exit 1
            fi
            
            # Rule 2: Staging can only receive merges from develop
            if [[ "$BASE_BRANCH" == "staging" && "$HEAD_BRANCH" != "develop" ]]; then
              echo "âŒ ERROR: Staging can only be updated from develop branch"
              echo "   Attempted: $HEAD_BRANCH â†’ staging" 
              echo "   Required: develop â†’ staging"
              exit 1
            fi
            
            echo "âœ… Branch flow rules validated successfully"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            DISPATCH_BRANCH="${{ github.event.inputs.branch }}"
            if [[ "$DISPATCH_BRANCH" != "develop" ]]; then
              echo "âŒ ERROR: Manual deployment only allowed for develop branch"
              exit 1
            fi
            echo "âœ… Manual deployment authorized for develop branch"
          fi

      - name: Set deployment variables
        id: vars
        run: |
          # Determine target branch
          if [[ "${{ github.event_name }}" == "push" ]]; then
            TARGET_BRANCH="${{ github.ref_name }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            TARGET_BRANCH="${{ github.event.pull_request.base.ref }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TARGET_BRANCH="${{ github.event.inputs.branch }}"
          fi
          
          if [[ "$TARGET_BRANCH" == "develop" ]]; then
            echo "HOST=${{ secrets.DEVELOP_HOST }}" >> $GITHUB_ENV
            echo "ENV_NAME=development" >> $GITHUB_ENV
            echo "ENV_URL=https://develop.api.cms.itqan.dev" >> $GITHUB_ENV
            echo "COMPOSE_FILE=deployment/docker/docker-compose.develop.yml" >> $GITHUB_ENV
            echo "BRANCH=develop" >> $GITHUB_ENV
          elif [[ "$TARGET_BRANCH" == "staging" ]]; then
            echo "HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
            echo "ENV_NAME=staging" >> $GITHUB_ENV
            echo "ENV_URL=https://staging.api.cms.itqan.dev" >> $GITHUB_ENV
            echo "COMPOSE_FILE=deployment/docker/docker-compose.staging.yml" >> $GITHUB_ENV
            echo "BRANCH=staging" >> $GITHUB_ENV
          elif [[ "$TARGET_BRANCH" == "main" ]]; then
            echo "HOST=${{ secrets.PROD_HOST }}" >> $GITHUB_ENV
            echo "ENV_NAME=production" >> $GITHUB_ENV
            echo "ENV_URL=https://api.cms.itqan.dev" >> $GITHUB_ENV
            echo "COMPOSE_FILE=deployment/docker/docker-compose.production.yml" >> $GITHUB_ENV
            echo "BRANCH=main" >> $GITHUB_ENV
          fi

      - name: Deploy to ${{ env.ENV_NAME }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            echo "ğŸš€ Starting deployment to ${{ env.ENV_NAME }} environment..."
            echo "ğŸ“‹ Target: ${{ env.ENV_URL }}"
            echo "ğŸŒ¿ Branch: ${{ env.BRANCH }}"
            
            # Navigate to application directory
            cd /srv/cms-backend
            
            # Pull latest changes
            echo "ğŸ“¥ Fetching latest code from GitHub..."
            git fetch origin ${{ env.BRANCH }}
            git reset --hard origin/${{ env.BRANCH }}
            
            # Display current commit
            echo "ğŸ“‹ Current commit: $(git rev-parse --short HEAD) - $(git log -1 --pretty=%B)"
            
            # Generate environment file from GitHub Secrets (per environment)
            echo "ğŸ§© Generating environment file from secrets..."
            mkdir -p deployment/docker
            if [ "${{ env.ENV_NAME }}" = "development" ]; then
              cat > deployment/docker/.env << 'EOF'
DJANGO_SETTINGS_MODULE=config.settings.development
SECRET_KEY=${{ secrets.DEVELOP_SECRET_KEY }}
DEBUG=False
SITE_DOMAIN=develop.api.cms.itqan.dev
DB_ENGINE=django.db.backends.postgresql
DB_NAME=${{ secrets.DEVELOP_DB_NAME }}
DB_USER=${{ secrets.DEVELOP_DB_USER }}
DB_PASSWORD=${{ secrets.DEVELOP_DB_PASSWORD }}
DB_HOST=${{ secrets.DEVELOP_DB_HOST }}
DB_PORT=25060
PGSSLMODE=require
ALLOWED_HOSTS=develop.api.cms.itqan.dev
CORS_ALLOWED_ORIGINS=https://dev.cms.itqan.dev,http://localhost:3000
EOF
            elif [ "${{ env.ENV_NAME }}" = "staging" ]; then
              cat > deployment/docker/.env << 'EOF'
DJANGO_SETTINGS_MODULE=config.settings.staging
SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}
DEBUG=False
SITE_DOMAIN=staging.api.cms.itqan.dev
DB_ENGINE=django.db.backends.postgresql
DB_NAME=${{ secrets.STAGING_DB_NAME }}
DB_USER=${{ secrets.STAGING_DB_USER }}
DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}
DB_HOST=${{ secrets.STAGING_DB_HOST }}
DB_PORT=25060
PGSSLMODE=require
ALLOWED_HOSTS=staging.api.cms.itqan.dev
CORS_ALLOWED_ORIGINS=https://staging.cms.itqan.dev,http://localhost:3000
EOF
            elif [ "${{ env.ENV_NAME }}" = "production" ]; then
              cat > deployment/docker/.env << 'EOF'
DJANGO_SETTINGS_MODULE=config.settings.production
SECRET_KEY=${{ secrets.PROD_SECRET_KEY }}
DEBUG=False
SITE_DOMAIN=api.cms.itqan.dev
DB_ENGINE=django.db.backends.postgresql
DB_NAME=${{ secrets.PROD_DB_NAME }}
DB_USER=${{ secrets.PROD_DB_USER }}
DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}
DB_HOST=${{ secrets.PROD_DB_HOST }}
DB_PORT=25060
PGSSLMODE=require
ALLOWED_HOSTS=api.cms.itqan.dev
CORS_ALLOWED_ORIGINS=https://cms.itqan.dev
EOF
            fi
            echo "âœ… Environment file generated at deployment/docker/.env"
            
            # Clean up existing containers and images
            echo "ğŸ§¹ Cleaning up existing containers..."
            docker compose -f ${{ env.COMPOSE_FILE }} down --remove-orphans || true
            docker container prune -f || true
            
            # Remove any conflicting containers by name
            echo "ğŸ—‘ï¸ Removing any conflicting containers..."
            docker rm -f docker-web-1 web cms-web backend || true
            
            # Deploy with Docker Compose (build and start)
            echo "ğŸ”§ Building and starting services..."
            docker compose -f ${{ env.COMPOSE_FILE }} up -d --build
            
            # Wait for services to be ready
            echo "â³ Waiting for services to start..."
            sleep 30
            
            # Health check
            echo "ğŸ” Performing health check..."
            if curl -f -s ${{ env.ENV_URL }}/health > /dev/null; then
              echo "âœ… Health check passed!"
            else
              echo "âš ï¸ Health check failed, checking container status..."
              docker compose -f ${{ env.COMPOSE_FILE }} ps
              docker compose -f ${{ env.COMPOSE_FILE }} logs web --tail 20
            fi
            
            # Clean up old Docker images
            echo "ğŸ§¹ Cleaning up old Docker images..."
            docker image prune -f || true
            
            echo "ğŸ‰ Deployment to ${{ env.ENV_NAME }} completed successfully!"
            echo "ğŸŒ Application URL: ${{ env.ENV_URL }}"
